---
order: 8
title: for
---

# x-for

Alpine's `x-for` directive allows you to create DOM elements by iterating through a list. Here's a simple example of using it to create a list of colors based on an array.

```alpine
<ul x-data="{ colors: ['Red', 'Orange', 'Yellow'] }">
    <template x-for="color in colors">
        <li x-text="color"></li>
    </template>
</ul>
```

<!-- START_VERBATIM -->
<div class="demo">
    <ul x-data="{ colors: ['Red', 'Orange', 'Yellow'] }">
        <template x-for="color in colors">
            <li x-text="color"></li>
        </template>
    </ul>
</div>
<!-- END_VERBATIM -->

There are two rules worth noting about `x-for`:

>`x-for` MUST be declared on a `<template>` element
> That `<template>` element MUST contain only one root element

<a name="keys"></a>
## Keys

It is important to specify unique keys for each `x-for` iteration if you are going to be re-ordering items. Without dynamic keys, Alpine may have a hard time keeping track of what re-orders and will cause odd side-effects.

```alpine
<ul x-data="{ colors: [
    { id: 1, label: 'Red' },
    { id: 2, label: 'Orange' },
    { id: 3, label: 'Yellow' },
]}">
    <template x-for="color in colors" :key="color.id">
        <li x-text="color.label"></li>
    </template>
</ul>
```

Now if the colors are added, removed, re-ordered, or their "id"s change, Alpine will preserve or destroy the iterated `<li>`elements accordingly.

<a name="accessing-indexes"></a>
## Accessing indexes

If you need to access the index of each item in the iteration, you can do so using the `([item], [index]) in [items]` syntax like so:

```alpine
<ul x-data="{ colors: ['Red', 'Orange', 'Yellow'] }">
    <template x-for="(color, index) in colors">
        <li>
            <span x-text="index + ': '"></span>
            <span x-text="color"></span>
        </li>
    </template>
</ul>
```

You can also access the index inside a dynamic `:key` expression.

```alpine
<template x-for="(color, index) in colors" :key="index">
```

<a name="iterating-over-a-range"></a>
## Iterating over a range

If you need to simply loop `n` number of times, rather than iterate through an array, Alpine offers a short syntax.

```alpine
<ul>
    <template x-for="i in 10">
        <li x-text="i"></li>
    </template>
</ul>
```

`i` in this case can be named anything you like.

<a name="contents-of-a-template"></a>
## Contents of a `<template>`

As mentioned above, an `<template>` tag must contain only one root element.

For example, the following code will not work:

```alpine
<template x-for="color in colors">
    <span>The next color is </span><span x-text="color">
</template>
```

but this code will work:
```alpine
<template x-for="color in colors">
    <p>
        <span>The next color is </span><span x-text="color">
    </p>
</template>
```

## Hydration

A common issue with server rendering templates with looping behavior is deciding what should be static markup and what should be handled by Alpine. Fortunately, Alpine is capable of looking at the elements in the DOM near the template and selectively hydrating the elements, adding the appropriate scopes and reordering elements as necessary.

For example, you might server render a component like this:

```alpine
<ul x-data="{ colors: [
    { id: 1, label: 'Red' },
    { id: 2, label: 'Orange' },
    { id: 3, label: 'Yellow' },
]}">
    <template x-for.hydrate="color in colors" :key="color.id">
        <li x-text="color.label"></li>
    </template>
    <li x-text="color.label" key="1">Red</li>
    <li x-text="color.label" key="2">Orange</li>
    <li x-text="color.label" key="3">Yellow</li>
</ul>
```

Here Alpine will see the static markup with `key` attributes (`key` is REQUIRED for hydration to work) and will hydrate the template with the appropriate data. From the attached scopes and treat them just like any element generated by the template itself.

It will event correct the order and text like so:

```alpine
<ul x-data="{ colors: [
    { id: 1, label: 'Red' },
    { id: 2, label: 'Orange' },
    { id: 3, label: 'Yellow' },
]}">
    <template x-for.hydrate="color in colors" :key="color.id">
        <li x-text="color.label"></li>
    </template>
    <li x-text="color.label" key="2">Orange</li>
    <li x-text="color.label" key="3">Red</li>
    <li x-text="color.label" key="1">Red</li>
</ul>
```

<!-- START_VERBATIM -->
<div class="demo">
    <ul x-data="{ colors: [
        { id: 1, label: 'Red' },
        { id: 2, label: 'Orange' },
        { id: 3, label: 'Yellow' },
    ]}">
        <template x-for.hydrate="color in colors" :key="color.id">
            <li x-text="color.label"></li>
        </template>
        <li x-text="color.label" key="2">Orange</li>
        <li x-text="color.label" key="3">Red</li>
        <li x-text="color.label" key="1">Red</li>
    </ul>
</div>
<!-- END_VERBATIM -->

### Limitations

Currently, extra elements as siblings of the template that have a `key` attribute will not be removed and may cause errors.

Without Morph (see below), the static markup will be used as is. It will not be updated if differences exist between the static markup and the template markup.

### Using with Morph

If you are using [Morph](https://alpinejs.dev/plugins/morph), you can leave the directives off of the static markup and Morph will automatically add them for you. This is force the static markup to also have a matching layout to the template when difference exist, while still allowing you to server render the template.

```alpine
<ul x-data="{ colors: [
    { id: 1, label: 'Red' },
    { id: 2, label: 'Orange' },
    { id: 3, label: 'Yellow' },
]}">
    <template x-for.hydrate="color in colors" :key="color.id">
        <li x-text="color.label"></li>
    </template>
    <li key="2">Orange</li>
    <li key="3">Red</li>
    <li key="1">Red</li>
</ul>
```

<!-- START_VERBATIM -->
<div class="demo">
    <ul x-data="{ colors: [
        { id: 1, label: 'Red' },
        { id: 2, label: 'Orange' },
        { id: 3, label: 'Yellow' },
    ]}">
        <template x-for.hydrate="color in colors" :key="color.id">
            <li x-text="color.label" style="color: blue"></li>
        </template>
        <li key="2">Orange</li>
        <li key="3">Red</li>
        <li key="1">Red</li>
    </ul>
</div>
<!-- END_VERBATIM -->